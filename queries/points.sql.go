// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: points.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type CreatePointsParams struct {
	Geom               interface{}        `json:"geom"`
	Visited            pgtype.Timestamptz `json:"visited"`
	DataSourceFilepath string             `json:"dataSourceFilepath"`
}

const getDataSourcePointsCount = `-- name: GetDataSourcePointsCount :one
select count(*)
from get_points(arg_data_source_filepath := $1)
`

func (q *Queries) GetDataSourcePointsCount(ctx context.Context, dataSourceFilepath string) (int64, error) {
	row := q.db.QueryRow(ctx, getDataSourcePointsCount, dataSourceFilepath)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGeoJson = `-- name: GetGeoJson :one
with a as (
        select st_simplify(st_makeline(geom::geometry order by visited), 0.001) c
        from points
        group by data_source_filepath
) select st_asgeojson(st_linemerge(st_union(c)))::text from a
`

func (q *Queries) GetGeoJson(ctx context.Context) (string, error) {
	row := q.db.QueryRow(ctx, getGeoJson)
	var column_1 string
	err := row.Scan(&column_1)
	return column_1, err
}

const getLineByFilepath = `-- name: GetLineByFilepath :one
select
    st_asgeojson(
        st_makeline(geom::geometry order by visited desc)
    )::text
from points
where data_source_filepath = $1
`

func (q *Queries) GetLineByFilepath(ctx context.Context, dataSourceFilepath string) (string, error) {
	row := q.db.QueryRow(ctx, getLineByFilepath, dataSourceFilepath)
	var column_1 string
	err := row.Scan(&column_1)
	return column_1, err
}

const getLineStrings = `-- name: GetLineStrings :many
select
    st_asgeojson(
        st_makeline(geom::geometry)
    )::text lines
from get_points(
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
group by filepath::text
`

type GetLineStringsParams struct {
	VisitedBefore      pgtype.Timestamptz `json:"visitedBefore"`
	VisitedAfter       pgtype.Timestamptz `json:"visitedAfter"`
	DataSourceFilepath pgtype.Text        `json:"dataSourceFilepath"`
	DataSourceType     pgtype.Text        `json:"dataSourceType"`
	WithinMeters       pgtype.Float8      `json:"withinMeters"`
	WithinMetersLongX  pgtype.Float8      `json:"withinMetersLongX"`
	WithinMetersLatY   pgtype.Float8      `json:"withinMetersLatY"`
}

func (q *Queries) GetLineStrings(ctx context.Context, arg *GetLineStringsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getLineStrings,
		arg.VisitedBefore,
		arg.VisitedAfter,
		arg.DataSourceFilepath,
		arg.DataSourceType,
		arg.WithinMeters,
		arg.WithinMetersLongX,
		arg.WithinMetersLatY,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var lines string
		if err := rows.Scan(&lines); err != nil {
			return nil, err
		}
		items = append(items, lines)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
